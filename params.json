{"name":"Gocupi","tagline":"Polargraph (vertical plotter / drawing machine) written in Go","body":"gocupi\r\n======\r\n\r\nPolargraph (vertical plotter / drawing machine) written in Go. Inspired by [Polargraph](http://www.polargraph.co.uk/) and [drawbot](http://marginallyclever.com/blog/drawbot/) projects, designed with the help of the [Dallas Makerspace](http://dallasmakerspace.org/)\r\n\r\nThe difference with Gocupi is that it uses a Raspberry Pi to do most of the processing instead of relying on a microcontroller to parse commands. This gives it the ability to render complex svg files that would not fit in memory on a microcontroller.\r\n\r\nBeta versions of prebuilt hardware are now available at [gocupi.com](http://gocupi.com)\r\n\r\nQuickstart Guide\r\n================\r\n\r\nInstall Go\r\n-----------\r\nThe full install guide is on [golang.org](http://golang.org/doc/install). For the Raspberry Pi you can [download precompiled binaries](http://dave.cheney.net/unofficial-arm-tarballs) to avoid the lengthy process of building go from source.\r\n\r\nFor example, installing go to the default location with a precompiled binary on a raspberry pi just takes 3 commands:\r\n\r\n    wget http://dave.cheney.net/paste/go.1.3.linux-arm~multiarch-armv6-1.tar.gz\r\n    sudo tar -C /usr/local -xzf go.1.3.linux-arm~multiarch-armv6-1.tar.gz\r\n    sudo echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.profile\r\n\r\n(You must set GOROOT also if you install go to someplace besides the default /usr/local/go)\r\n\r\nFix the serial communication\r\n----------------------------\r\nChange the default serial communication by editing /boot/cmdline.txt and remove references to `/dev/ttyAMA0`\r\n\r\nDisable the getty on that serial port in /etc/inittab by commenting out references to `/dev/ttyAMA0`\r\n\r\nIn order to reset the serial communication port we need to `sudo reboot`\r\n\r\nSetup gopath folder\r\n----------------------------\r\nSetup the folder for your gopath and set some path variables\r\n\r\n    mkdir ~/gopath\r\n    sudo echo 'export GOPATH=$HOME/gopath' >> ~/.profile\r\n    sudo echo 'export PATH=$PATH:$HOME/gopath/bin' >> ~/.profile\r\n\r\nInstall needed dependency\r\n---------------------\r\nInstall mercurial\r\n`sudo apt-get install mercurial`\r\n\r\nDownload and build gocupi\r\n---------------------------\r\nFrom your home directory\r\n`go get github.com/brandonagr/gocupi`\r\n\r\nRun gocupi\r\n----------\r\n`gocupi` The gocupi executable should now be in your $GOPATH\\bin folder, you can run the command with no arguments to display the help and what command are available\r\n\r\n`gocupi setup 1000 700 700` The setup command can be used to initialize the dimensions of the polargraph hardware, the setup is stored in the generated gocupi_config.xml file\r\n\r\n`gocupi -toimage grid 100 10` The -toimage flag causes the system to draw to an output.png instead of trying to control the stepper motors over serial\r\n\r\nBasic polargraph description\r\n============================\r\nTwo stepper motors move a pen hanging from threads to draw stuff out on a whiteboard or any vertical surface. A program written in Go runs on the Pi, it sends movement commands over serial to an arduino, which then pulses the step pin on the stepper drivers to make the stepper motors move.\r\n\r\nThis project is different from most other Polargraphs in that there is no step generation code on the arduino, everything is calculated in Go and then the arduino just receives a stream of step deltas that it stores in a memory buffer and then executes. Since all logic is written in Go running on the Pi it allows using more advanced interpolation models for smooth drawing, not needing to use fixed point or single precision floats for calculations, not needing to reflash the arduino often when making code changes, etc.\r\n\r\nDesign description\r\n==================\r\nIn the Go program, there are several channels that form a pipeline where separate functions execute the different pipeline stages. All of the stages are run in different goroutines so that they execute concurrently.\r\n\r\n* The first stage in the pipeline is generating X,Y coordinates, it can either read those points from an svg file, gcode file, mouse data, or generate them according to an algorithm(such as hilbert space filling curve, spiral, circle, parabolic graph, etc).\r\n\r\n* The second stage takes an X,Y coordinate and interpolates the movement from the previous X,Y position to the new position by evaluating the pen position every 2 milliseconds. It takes into account acceleration, entry speed, and exit speed so that it can slow down the pen smoothly before the end of the current line segment if needed. It calculates how much the stepper motors need to turn to move the pen to the interpolated X,Y location over those 2 milliseconds.\r\n\r\n* The final stage takes the step commands and writes them over serial to the arduino. The arduino first sends a byte requesting a certain amount of data when the buffer has enough room, then the raspberry pi sends that much data to the arduino.\r\n\r\n* The arduino has a 1KB buffer of step commands and uses simple linear interpolation to see if it should generate a pulse at the current time to move the stepper motor one step in a particular direction.\r\n\r\nIn order to generate single line art drawings(like the raspberry pi logo shown below) I followed the [makerbot](http://www.makerbot.com/blog/2012/03/12/single-line-art-traveling-salesman-problem-tutorial/) and [eggbot](http://wiki.evilmadscience.com/TSP_art) tutorials which show how to convert a grayscale image to a stippled image to a path to an svg file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}