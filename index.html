<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Gocupi by brandonagr</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Gocupi</h1>
        <h2>Polargraph (vertical plotter / drawing machine) written in Go</h2>

        <section id="downloads">
          <a href="https://github.com/brandonagr/gocupi/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/brandonagr/gocupi/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/brandonagr/gocupi" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
<p><img src="images/gopher_pi.png"/></p>

<p>Polargraph (vertical plotter / drawing machine) written in Go. Inspired by <a href="http://www.polargraph.co.uk/">Polargraph</a> and <a href="http://marginallyclever.com/blog/drawbot/">drawbot</a> projects, designed with the help of the <a href="http://dallasmakerspace.org/">Dallas Makerspace</a></p>

<p>Gocupi is different from existing systems in that it uses a Raspberry Pi to do most of the processing instead of relying on a microcontroller to parse commands. This gives it the ability to render complex svg files and patterns that would not fit in memory on a microcontroller.</p>



<p>
<img src="images/small_setup.jpg"/>
<img src="images/IMG_20121115_212000.jpg"/></p>

<h1>Get your own Gocupi</h1>

<p>A kickstarter campaign will be starting soon to allow you to get a prebuilt Gocupi. More information will be available at <a href="http://gocupi.com">gocupi.com</a></p>

<h1>
<a name="basic-polargraph-description" class="anchor" href="#basic-polargraph-description"><span class="octicon octicon-link"></span></a>What is a polargraph?</h1>

<p>Two stepper motors move a pen hanging from threads to draw stuff out on a whiteboard or any vertical surface. A program written in Go runs on the Pi, it sends movement commands over serial to an arduino, which then pulses the step pin on the stepper drivers to make the stepper motors move.</p>

<p>This project is different from most other Polargraphs in that there is no step generation code on the arduino, everything is calculated in Go and then the arduino just receives a stream of step deltas that it stores in a memory buffer and then executes. Since all logic is written in Go running on the Pi it allows using more advanced interpolation models for smooth drawing, not needing to use fixed point or single precision floats for calculations, not needing to reflash the arduino often when making code changes, etc.</p>

<h1>
<a name="design-description" class="anchor" href="#design-description"><span class="octicon octicon-link"></span></a>Design description</h1>

<p>In the Go program, there are several channels that form a pipeline where separate functions execute the different pipeline stages. All of the stages are run in different goroutines so that they execute concurrently.</p>

<ul>
<li>The first stage in the pipeline is generating X,Y coordinates, it can either read those points from an svg file, gcode file, mouse data, or generate them according to an algorithm(such as hilbert space filling curve, spiral, circle, parabolic graph, etc).</li>
<li>The second stage takes an X,Y coordinate and interpolates the movement from the previous X,Y position to the new position by evaluating the pen position every 2 milliseconds. It takes into account acceleration, entry speed, and exit speed so that it can slow down the pen smoothly before the end of the current line segment if needed. It calculates how much the stepper motors need to turn to move the pen to the interpolated X,Y location over those 2 milliseconds.</li>
<li>The final stage takes the step commands and writes them over serial to the arduino. The arduino first sends a byte requesting a certain amount of data when the buffer has enough room, then the raspberry pi sends that much data to the arduino.</li>
<li>The arduino has a 1KB buffer of step commands and uses simple linear interpolation to see if it should generate a pulse at the current time to move the stepper motor one step in a particular direction.</li>
</ul><p>In order to generate single line art drawings(like the raspberry pi & gopher logo shown above) I followed the <a href="http://www.makerbot.com/blog/2012/03/12/single-line-art-traveling-salesman-problem-tutorial/">makerbot</a> and <a href="http://wiki.evilmadscience.com/TSP_art">eggbot</a> tutorials which show how to convert a grayscale image to a stippled image to a path to an svg file.</p>

<h1>Interpolation</h1>
<p>The system uses simple <a href="http://www.pmdcorp.com/news/articles/html/Mathematics_of_Motion_Control_Profiles.cfm">trapezoid based velocity</a> to move the gondola smoothly. During interpolation there are three phases, acceleration at a constant rate, cruising at a constant speed, and decelerating at a constant rate. It handles the edge cases where you don't have enough distance to accelerate or decelerate fully.</p>
<p>For each line segment it is about to draw it calculates the angle turn at the end of the segment to the next line segment to determine the target exit speed. Ie if it has to make a 90 degree turn, then it wants to come to a stop at the end of the current line segment, if it isn't turning and just going straight then it doesn't need to slow down at all.</p>
<p><img src="images/chart_interp.png"></p>
<p>In that chart you can see the constant acceleration phase as velocity is increasing, and then the velocity of the pen in the cartesian coordinate system is constant. The reason for the steps in velocity is because of the instantaneous changes in direction between line segments. Even though it does slow down to make a turn it does not stop completly for every turn.</p>
<p><img src="images/chart_hilbert.png"></p>
<p>In this chart there is not enough distance to reach the target velocity, so there is only an acceleration and then deceleration phase. It is making 90 degree turns, that is why the velocity goes to 0 between each line segment. The thickness of the velocity lines is due to the limited resolution of the stepper motors, which are running at 1/8 microsteps, and the arduino interpolates to a precision of 1/32 of a microstep.</p>
      </section>
    </div>    
  </body>
</html>